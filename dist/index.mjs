import{writable as t,get as e,derived as r}from"svelte/store";const s=(t,e)=>{if(!Array.isArray(t.validators))return null;for(const r of t.validators)if("function"==typeof r)try{const s=r(e,t.control);if(null!=s)return s}catch(t){console.error("validator error",r,t)}return null};var o,i=new Uint8Array(16);function l(){if(!o&&!(o="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return o(i)}var n=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function a(t){return"string"==typeof t&&n.test(t)}for(var u=[],c=0;c<256;++c)u.push((c+256).toString(16).substr(1));function d(t,e,r){var s=(t=t||{}).random||(t.rng||l)();if(s[6]=15&s[6]|64,s[8]=63&s[8]|128,e){r=r||0;for(var o=0;o<16;++o)e[r+o]=s[o];return e}return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=(u[t[e+0]]+u[t[e+1]]+u[t[e+2]]+u[t[e+3]]+"-"+u[t[e+4]]+u[t[e+5]]+"-"+u[t[e+6]]+u[t[e+7]]+"-"+u[t[e+8]]+u[t[e+9]]+"-"+u[t[e+10]]+u[t[e+11]]+u[t[e+12]]+u[t[e+13]]+u[t[e+14]]+u[t[e+15]]).toLowerCase();if(!a(r))throw TypeError("Stringified UUID is invalid");return r}(s)}const h={type:"string"};class v{constructor(e,r){var s,o;this.id=d(),this.validators=t({validators:e,control:this}),this.meta=t(null!==(s=Object.assign(Object.assign({},h),r))&&void 0!==s?s:{}),this.label=null!==(o=null==r?void 0:r.name)&&void 0!==o?o:""}setMeta(t){this.meta.set(t)}patchMeta(t){const r=e(this.meta);this.meta.set(Object.assign(Object.assign({},r),t))}setValidators(t){Array.isArray(t)&&t.length&&this.validators.set({validators:t,control:this})}}class $ extends v{constructor(e,o=[],i){super(o,i),this.initial=e,this.value=t(this.initial),this.touched=t(!1),this.state=r([this.value,this.touched,this.validators,this.meta],(([t,e,r,o],i)=>{const l=this.initial!==t,n=s(r,t);let a=!0,u=!1,c=o,d="control";null!=n&&n instanceof Promise?(u=!0,i({$error:null,$valid:a,$touched:e,$dirty:l,$pending:u,$meta:c,$type:d}),n.then((t=>{a=null==t,u=!1,i({$error:t,$valid:a,$touched:e,$dirty:l,$pending:u,$meta:c,$type:d})})).catch((t=>{a=!1,i({$error:{serverError:!0},$valid:a,$touched:e,$dirty:l,$pending:u,$meta:c,$type:d})}))):(a=null==n,i({$error:n,$valid:a,$touched:e,$dirty:l,$pending:u,$meta:c,$type:d}))}))}setTouched(t){this.touched.set(t)}child(){return null}reset(t){void 0!==t&&(this.initial=t),this.value.set(this.initial),this.touched.set(!1)}}const p=/^([^.[]+)\.?(.*)$/;class m extends v{constructor(o,i=[],l){super(i,l),this.controlStore=t({}),this.controls={subscribe:this.controlStore.subscribe},this.valueDerived=r(this.controlStore,((t,e)=>{const s=Object.keys(t),o=s.map((e=>t[e].value));return r(o,(t=>t.reduce(((t,e,r)=>(t[s[r]]=e,t)),{}))).subscribe(e)})),this.touched=t(!1),this.childStateDerived=r(this.controlStore,((t,e)=>{const s=Object.keys(t),o=s.map((e=>t[e].state));return r(o,(t=>t.reduce(((t,e,r)=>(t[s[r]]=e,t)),{}))).subscribe(e)})),this.value={subscribe:this.valueDerived.subscribe,set:t=>this.setValue(t),update:t=>this.setValue(t(e(this.valueDerived)))},this.state=r([this.valueDerived,this.childStateDerived,this.validators,this.touched,this.meta],(([t,e,r,o,i])=>{const l={};let n=!0,a=o,u=!1,c=!1,d=i;for(const t of Object.keys(e)){const r=l[t]=e[t];n=n&&r.$valid,a=a||r.$touched,u=u||r.$dirty,c=c||r.$pending}const h=s(r,t),v=null==h&&n;return Object.assign({$error:h,$valid:v,$touched:a,$dirty:u,$pending:c,$meta:d,$type:"group"},l)})),this.controlStore.set(o)}iterateControls(t){const r=e(this.controlStore);Object.entries(r).forEach(t)}setValue(t){this.iterateControls((([e,r])=>{var s;const o=null!==(s=t&&t[e])&&void 0!==s?s:null;r.value.set(o)}))}patchValue(t){const r=e(this.valueDerived);this.setValue(Object.assign(Object.assign({},r),t))}addControl(t,e){this.controlStore.update((r=>(r[t]=e,r)))}removeControl(t){this.controlStore.update((e=>(delete e[t],e)))}setTouched(t){this.iterateControls((([e,r])=>{r.setTouched(t)})),this.touched.set(t)}child(t){const[r,s,o]=t.match(p)||[],i=e(this.controlStore),l=s&&i[s]||null;return l?o?l.child(o):l:null}reset(t){this.iterateControls((([e,r])=>{const s=t&&t[e]||void 0;r.reset(s)}))}}const b=/^\[(\d+)\]\.?(.*)$/;class y extends v{constructor(o,i=[],l){super(i,l),this._controls=o,this.controlStore=t(this._controls),this.touched=t(!1),this.controls={subscribe:this.controlStore.subscribe},this.valueDerived=r(this.controlStore,((t,e)=>r(t.map((t=>t.value)),(t=>t)).subscribe(e))),this.childStateDerived=r(this.controlStore,((t,e)=>r(t.map((t=>t.state)),(t=>t)).subscribe(e))),this.value={subscribe:this.valueDerived.subscribe,set:t=>this.setValue(t),update:t=>this.setValue(t(e(this.valueDerived)))},this.state=r([this.valueDerived,this.childStateDerived,this.validators,this.touched],(([t,r,o,i])=>{const l={list:[]};let n=!0;l.$touched=i;for(let t=0,e=r.length;t<e;t++){const e=r[t];l.list[t]=e,n=n&&e.$valid,l.$touched=l.$touched||e.$touched||!1,l.$dirty=l.$dirty||e.$dirty}return l.$error=s(o,t),l.$valid=null==l.$error&&n,l.$meta=e(this.meta),l.$type="array",l}))}iterateControls(t){e(this.controlStore).forEach(t)}sortArray(t){const r=e(this.controlStore);let s=t.map((t=>t.id)).map((t=>r.find((e=>e.id===t))));s=s.filter((t=>void 0!==t)),this.controlStore.set(s)}setValue(t){this.iterateControls(((e,r)=>{const s=t&&t[r]||null;e.value.set(s)}))}setTouched(t){this.touched.set(t),this.iterateControls((e=>e.setTouched(t)))}pushControl(t){this.controlStore.update((e=>(e.push(t),e)))}addControlAt(t,e){this.controlStore.update((r=>(r.splice(t,0,e),r)))}removeControlAt(t){this.controlStore.update((e=>(e.splice(t,1),e)))}removeControl(t){this.controlStore.update((e=>e.filter((e=>e!==t))))}slice(t,e){this.controlStore.update((r=>r.slice(t,e)))}child(t){const[r,s,o]=t.match(b)||[],i=e(this.controlStore),l=null!=s&&i[+s]||null;return l?o?l.child(o):l:null}reset(t){this.iterateControls(((e,r)=>{const s=t&&t[r]||null;e.reset(s)}))}}const f=(t,r)=>{if(!(r instanceof $))throw new Error("must be used with a Control class");const s=t.classList,o=r.state.subscribe((t=>{t.$error?(s.add("invalid"),s.remove("valid")):(s.add("valid"),s.remove("invalid")),t.$dirty?(s.add("dirty"),s.remove("pristine")):(s.add("pristine"),s.remove("dirty")),t.$touched?s.add("touched"):s.remove("touched")})),i=["blur","focusout"],l=()=>{e(r.state).$touched||r.setTouched(!0)};return i.forEach((e=>t.addEventListener(e,l))),{destroy(){i.forEach((e=>t.removeEventListener(e,l))),o()}}},g=t=>null==t||""==`${t}`,S=t=>""!==(null!=t&&!1!==t?`${t}`.trim():"")?null:{required:!0},C=/^([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$/,D=t=>g(t)||C.test(t)?null:{email:!0},V=t=>e=>g(e)||null==t||`${e}`.trim().length>=t?null:{minLength:t},j=t=>e=>g(e)||null==t||`${e}`.trim().length<=t?null:{maxLength:t},A=t=>g(t)||!isNaN(+t)?null:{number:!0},O=/^\d*\.?\d+$/,E=t=>g(t)||!isNaN(+t)&&O.test(`${t}`)?null:{decimal:!0},N=/^\d+$/,w=t=>g(t)||!isNaN(+t)&&N.test(`${t}`)?null:{integer:!0},T=t=>e=>g(e)||!isNaN(+e)&&(null==t||e>=t)?null:{min:t},x=t=>e=>g(e)||!isNaN(+e)&&(null==t||e<=t)?null:{max:t},L=t=>e=>g(e)||null==t||t.test(e)?null:{pattern:`${t}`};export{$ as Control,y as ControlArray,v as ControlBase,m as ControlGroup,f as controlClasses,E as decimal,D as email,w as integer,x as max,j as maxLength,T as min,V as minLength,A as number,L as pattern,S as required};
//# sourceMappingURL=index.mjs.map
