import{writable as t,get as e,derived as r}from"svelte/store";const s=(t,e)=>{if(!Array.isArray(t.validators))return null;for(const r of t.validators)if("function"==typeof r)try{const s=r(e,t.control);if(null!=s)return s}catch(t){console.error("validator error",r,t)}return null};var o,i=new Uint8Array(16);function n(){if(!o&&!(o="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return o(i)}var l=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function a(t){return"string"==typeof t&&l.test(t)}for(var u=[],c=0;c<256;++c)u.push((c+256).toString(16).substr(1));function h(t,e,r){var s=(t=t||{}).random||(t.rng||n)();if(s[6]=15&s[6]|64,s[8]=63&s[8]|128,e){r=r||0;for(var o=0;o<16;++o)e[r+o]=s[o];return e}return function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=(u[t[e+0]]+u[t[e+1]]+u[t[e+2]]+u[t[e+3]]+"-"+u[t[e+4]]+u[t[e+5]]+"-"+u[t[e+6]]+u[t[e+7]]+"-"+u[t[e+8]]+u[t[e+9]]+"-"+u[t[e+10]]+u[t[e+11]]+u[t[e+12]]+u[t[e+13]]+u[t[e+14]]+u[t[e+15]]).toLowerCase();if(!a(r))throw TypeError("Stringified UUID is invalid");return r}(s)}const d={type:"string"};class v{constructor(e,r){var s,o;this.id=h(),this.currentState=null,this.propagateChanges=!0,this.validators=t({validators:e,control:this}),this.meta=t(null!==(s=Object.assign(Object.assign({},d),r))&&void 0!==s?s:{}),this.label=null!==(o=null==r?void 0:r.name)&&void 0!==o?o:""}setMeta(t){this.meta.set(t)}patchMeta(t){const r=e(this.meta);this.meta.set(Object.assign(Object.assign({},r),t))}setValidators(t){Array.isArray(t)&&t.length&&this.validators.set({validators:t,control:this})}}class p extends v{constructor(e,o=[],i){super(o,i),this.initial=e,this.value=t(this.initial),this.touched=t(!1),this.state=r([this.value,this.touched,this.validators,this.meta],(([t,e,r,o],i)=>{const n=this.initial!==t,l=s(r,t);let a=!0,u=!1,c=o,h="control";null!=l&&l instanceof Promise?(u=!0,i({$error:null,$valid:a,$touched:e,$dirty:n,$pending:u,$meta:c,$type:h}),l.then((t=>{a=null==t,u=!1,i({$error:t,$valid:a,$touched:e,$dirty:n,$pending:u,$meta:c,$type:h})})).catch((t=>{a=!1,i({$error:{serverError:!0},$valid:a,$touched:e,$dirty:n,$pending:u,$meta:c,$type:h})}))):(a=null==l,i({$error:l,$valid:a,$touched:e,$dirty:n,$pending:u,$meta:c,$type:h}))}))}setTouched(t){this.touched.set(t)}child(){return null}reset(t){void 0!==t&&(this.initial=t),this.value.set(this.initial),this.touched.set(!1)}}const $=/^([^.[]+)\.?(.*)$/;class m extends v{constructor(o,i=[],n){super(i,n),this.controlStore=t({}),this.controls={subscribe:this.controlStore.subscribe},this.valueDerived=r(this.controlStore,((t,e)=>{const s=Object.keys(t),o=s.map((e=>t[e].value));return r(o,(t=>t.reduce(((t,e,r)=>(t[s[r]]=e,t)),{}))).subscribe(e)})),this.touched=t(!1),this.childStateDerived=r(this.controlStore,((t,e)=>{const s=Object.keys(t),o=s.map((e=>t[e].state));return r(o,(t=>t.reduce(((t,e,r)=>(t[s[r]]=e,t)),{}))).subscribe(e)})),this.value={subscribe:this.valueDerived.subscribe,set:t=>this.setValue(t),update:t=>this.setValue(t(e(this.valueDerived)))},this.state=r([this.valueDerived,this.childStateDerived,this.validators,this.touched,this.meta],(([t,e,r,o,i])=>{if(!this.propagateChanges&&null!==this.currentState)return this.currentState;console.log("propagateState");const n={};let l=!0,a=o,u=!1,c=!1,h=i;for(const t of Object.keys(e)){const r=n[t]=e[t];l=l&&r.$valid,a=a||r.$touched,u=u||r.$dirty,c=c||r.$pending}const d=s(r,t),v=null==d&&l;let p=Object.assign({$error:d,$valid:v,$touched:a,$dirty:u,$pending:c,$meta:h,$type:"group"},n);return this.currentState=p,p})),this.controlStore.set(o)}iterateControls(t){const r=e(this.controlStore);Object.entries(r).forEach(t)}setValue(t){this.iterateControls((([e,r])=>{var s;const o=null!==(s=t&&t[e])&&void 0!==s?s:null;r.value.set(o)}))}patchValue(t){const r=e(this.valueDerived);this.setValue(Object.assign(Object.assign({},r),t))}addControl(t,e,r){r&&!1===r.propagateChanges&&(this.propagateChanges=!1),this.controlStore.update((r=>(r[t]=e,r))),this.propagateChanges=!0}removeControl(t,e){e&&!1===e.propagateChanges&&(this.propagateChanges=!1),this.controlStore.update((e=>(delete e[t],e))),this.propagateChanges=!0}setTouched(t){this.iterateControls((([e,r])=>{r.setTouched(t)})),this.touched.set(t)}child(t){const[r,s,o]=t.match($)||[],i=e(this.controlStore),n=s&&i[s]||null;return n?o?n.child(o):n:null}reset(t){this.iterateControls((([e,r])=>{const s=t&&t[e]||void 0;r.reset(s)}))}}const g=/^\[(\d+)\]\.?(.*)$/;class b extends v{constructor(o,i=[],n){super(i,n),this._controls=o,this.controlStore=t(this._controls),this.touched=t(!1),this.controls={subscribe:this.controlStore.subscribe},this.valueDerived=r(this.controlStore,((t,e)=>r(t.map((t=>t.value)),(t=>t)).subscribe(e))),this.childStateDerived=r(this.controlStore,((t,e)=>r(t.map((t=>t.state)),(t=>t)).subscribe(e))),this.value={subscribe:this.valueDerived.subscribe,set:t=>this.setValue(t),update:t=>this.setValue(t(e(this.valueDerived)))},this.state=r([this.valueDerived,this.childStateDerived,this.validators,this.touched],(([t,r,o,i])=>{const n={list:[]};let l=!0;n.$touched=i;for(let t=0,e=r.length;t<e;t++){const e=r[t];n.list[t]=e,l=l&&e.$valid,n.$touched=n.$touched||e.$touched||!1,n.$dirty=n.$dirty||e.$dirty}return n.$error=s(o,t),n.$valid=null==n.$error&&l,n.$meta=e(this.meta),n.$type="array",n}))}iterateControls(t){e(this.controlStore).forEach(t)}sortArray(t){const r=e(this.controlStore);let s=t.map((t=>t.id)).map((t=>r.find((e=>e.id===t))));s=s.filter((t=>void 0!==t)),this.controlStore.set(s)}setValue(t){this.iterateControls(((e,r)=>{const s=t&&t[r]||null;e.value.set(s)}))}setTouched(t){this.touched.set(t),this.iterateControls((e=>e.setTouched(t)))}pushControl(t){this.controlStore.update((e=>(e.push(t),e)))}addControlAt(t,e){this.controlStore.update((r=>(r.splice(t,0,e),r)))}removeControlAt(t){this.controlStore.update((e=>(e.splice(t,1),e)))}removeControl(t){this.controlStore.update((e=>e.filter((e=>e!==t))))}slice(t,e){this.controlStore.update((r=>r.slice(t,e)))}child(t){const[r,s,o]=t.match(g)||[],i=e(this.controlStore),n=null!=s&&i[+s]||null;return n?o?n.child(o):n:null}reset(t){this.iterateControls(((e,r)=>{const s=t&&t[r]||null;e.reset(s)}))}}const y=(t,r)=>{if(!(r instanceof p))throw new Error("must be used with a Control class");const s=t.classList,o=r.state.subscribe((t=>{t.$error?(s.add("invalid"),s.remove("valid")):(s.add("valid"),s.remove("invalid")),t.$dirty?(s.add("dirty"),s.remove("pristine")):(s.add("pristine"),s.remove("dirty")),t.$touched?s.add("touched"):s.remove("touched")})),i=["blur","focusout"],n=()=>{e(r.state).$touched||r.setTouched(!0)};return i.forEach((e=>t.addEventListener(e,n))),{destroy(){i.forEach((e=>t.removeEventListener(e,n))),o()}}},f=t=>null==t||""==`${t}`,S=t=>""!==(null!=t&&!1!==t?`${t}`.trim():"")?null:{required:!0},C=/^([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$/,D=t=>f(t)||C.test(t)?null:{email:!0},V=t=>e=>f(e)||null==t||`${e}`.trim().length>=t?null:{minLength:t},j=t=>e=>f(e)||null==t||`${e}`.trim().length<=t?null:{maxLength:t},A=t=>f(t)||!isNaN(+t)?null:{number:!0},O=/^\d*\.?\d+$/,E=t=>f(t)||!isNaN(+t)&&O.test(`${t}`)?null:{decimal:!0},N=/^\d+$/,w=t=>f(t)||!isNaN(+t)&&N.test(`${t}`)?null:{integer:!0},T=t=>e=>f(e)||!isNaN(+e)&&(null==t||e>=t)?null:{min:t},x=t=>e=>f(e)||!isNaN(+e)&&(null==t||e<=t)?null:{max:t},L=t=>e=>f(e)||null==t||t.test(e)?null:{pattern:`${t}`};export{p as Control,b as ControlArray,v as ControlBase,m as ControlGroup,y as controlClasses,E as decimal,D as email,w as integer,x as max,j as maxLength,T as min,V as minLength,A as number,L as pattern,S as required};
//# sourceMappingURL=index.mjs.map
