{"version":3,"file":"index.mjs","sources":["../src/utils.ts","../node_modules/uuid/dist/esm-browser/rng.js","../node_modules/uuid/dist/esm-browser/regex.js","../node_modules/uuid/dist/esm-browser/validate.js","../node_modules/uuid/dist/esm-browser/stringify.js","../node_modules/uuid/dist/esm-browser/v4.js","../src/control.ts","../src/use-actions.ts","../src/validators.ts"],"sourcesContent":["import { ValidatorFn } from \"./validators\";\nimport {ControlValidators} from \"./interfaces\";\n\n\nexport const chainValidators: <T>(validators: ControlValidators<T>) => ValidatorFn = (\n\tvalidators\n) => {\n\tif (!Array.isArray(validators.validators)) return (value: any) => null;\n\treturn (fieldValue) => {\n\t\tfor (const validator of validators.validators) {\n\t\t\tconst result = validator(fieldValue, validators.control);\n\t\t\tif (result) return result;\n\t\t}\n\t\treturn null;\n\t};\n};\n\nexport const validateIterated = <T>(\n\tvalidators: ControlValidators<T>,\n\tfieldValue: T\n) => {\n\tif (!Array.isArray(validators.validators)) return null;\n\tfor (const validator of validators.validators) {\n\t\tif (typeof validator === \"function\") {\n\t\t\ttry {\n\t\t\t\tconst result = validator(fieldValue, validators.control);\n\t\t\t\tif (result != null) return result;\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(`validator error`, validator, e);\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n};\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import { derived, get, Readable, writable, Writable } from \"svelte/store\";\nimport { validateIterated } from \"./utils\";\nimport { ValidationError, ValidatorFn } from \"./validators\";\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n\t$ControlState,\n\tControlBaseInterface, ControlEventOptions,\n\tControlState,\n\tControlTypes,\n\tControlValidators,\n\tFormControlMeta\n} from \"./interfaces\";\n\nconst defaultMeta:FormControlMeta = {\n\ttype: 'string'\n}\n\nexport abstract class ControlBase<T = any> implements ControlBaseInterface<T> {\n\tpublic validators: Writable<ControlValidators<T>>;\n\n\tpublic meta: Writable<FormControlMeta>;\n\n\tpublic id: string = uuidv4()\n\n\tpublic currentState: ControlState<T> | null = null\n\n\tpublic propagateChanges: boolean = true\n\n\tpublic label: string\n\n\tconstructor(\n\t\tvalidators: ValidatorFn<T>[],\n\t\tmeta?: FormControlMeta\n) {\n\t\tthis.validators = writable({validators, control: this});\n\t\tthis.meta = writable({...defaultMeta,...meta} ?? {});\n\t\tthis.label = meta?.name ?? '';\n\t}\n\t\n\tabstract value: Writable<T>;\n\n\tabstract state: Readable<ControlState<T>>;\n\n\tabstract child(path: string): ControlBaseInterface<T> | null;\n\n\tabstract reset(value?: T): void;\n\n\tabstract setTouched(touched: boolean): void;\n\n\tsetMeta(meta: FormControlMeta) {\n\t\tthis.meta.set(meta);\n\t}\n\tpatchMeta(meta: Partial<FormControlMeta>) {\n\t\tconst currentMeta = get(this.meta);\n\t\tthis.meta.set({...currentMeta,...meta});\n\t}\n\n\tsetValidators(validators: ValidatorFn<T>[]) {\n\t\tif (!(Array.isArray(validators) && validators.length)) return;\n\t\tthis.validators.set({validators, control: this});\n\t}\n}\n\nexport class Control<T = ControlTypes> extends ControlBase<T> {\n\tvalue = writable<T>(this.initial);\n\ttouched = writable(false);\n\tstate = derived<\n\t\t[Writable<T>, Writable<boolean>, Writable<ControlValidators<T>>, Writable<FormControlMeta>],\n\t\tControlState<T>\n\t>(\n\t\t[this.value, this.touched, this.validators,this.meta],\n\t\t([value, $touched, validators, meta], set) => {\n\t\t\tconst $dirty = this.initial !== value;\n\n\t\t\tconst $error = validateIterated(validators, value);\n\n\t\t\tlet $valid = true;\n\t\t\tlet $pending = false;\n\t\t\tlet $meta = meta;\n\t\t\tlet $type = 'control';\n\t\t\tif ($error != null && $error instanceof Promise) {\n\t\t\t\t$pending = true;\n\n\t\t\t\tset({\n\t\t\t\t\t$error: null,\n\t\t\t\t\t$valid,\n\t\t\t\t\t$touched,\n\t\t\t\t\t$dirty,\n\t\t\t\t\t$pending,\n\t\t\t\t\t$meta,\n\t\t\t\t\t$type\n\t\t\t\t} as ControlState<T>);\n\n\t\t\t\t$error\n\t\t\t\t\t.then((ret) => {\n\t\t\t\t\t\t$valid = ret == null;\n\t\t\t\t\t\t$pending = false;\n\t\t\t\t\t\tset({\n\t\t\t\t\t\t\t$error: ret,\n\t\t\t\t\t\t\t$valid,\n\t\t\t\t\t\t\t$touched,\n\t\t\t\t\t\t\t$dirty,\n\t\t\t\t\t\t\t$pending,\n\t\t\t\t\t\t\t$meta,\n\t\t\t\t\t\t\t$type\n\t\t\t\t\t\t} as ControlState<T>);\n\t\t\t\t\t})\n\t\t\t\t\t.catch((err) => {\n\t\t\t\t\t\t$valid = false;\n\t\t\t\t\t\tset({\n\t\t\t\t\t\t\t$error: {\n\t\t\t\t\t\t\t\tserverError: true,\n\t\t\t\t\t\t\t} as ValidationError<boolean>,\n\t\t\t\t\t\t\t$valid,\n\t\t\t\t\t\t\t$touched,\n\t\t\t\t\t\t\t$dirty,\n\t\t\t\t\t\t\t$pending,\n\t\t\t\t\t\t\t$meta,\n\t\t\t\t\t\t\t$type\n\t\t\t\t\t\t} as ControlState<T>);\n\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t$valid = $error == null;\n\n\t\t\t\tset({\n\t\t\t\t\t$error,\n\t\t\t\t\t$valid,\n\t\t\t\t\t$touched,\n\t\t\t\t\t$dirty,\n\t\t\t\t\t$pending,\n\t\t\t\t\t$meta,\n\t\t\t\t\t$type\n\t\t\t\t} as ControlState<T>);\n\t\t\t}\n\t\t}\n\t);\n\n\tconstructor(\n\t\tpublic initial: T,\n\t\tvalidators: ValidatorFn<T>[] = [],\n\t\tmeta?: FormControlMeta\n\t) {\n\t\tsuper(validators, meta);\n\t}\n\n\tsetTouched(touched: boolean) {\n\t\tthis.touched.set(touched);\n\t}\n\n\tchild(): ControlBaseInterface<T> | null {\n\t\treturn null!;\n\t}\n\n\n\treset(value?: T) {\n\t\tif (value !== undefined) this.initial = value;\n\t\tthis.value.set(this.initial);\n\t\tthis.touched.set(false);\n\t}\n}\n\ntype Controls<T> = { [K in keyof T]: ControlBaseInterface<T[K]> };\ntype ControlsState<T> = { [K in keyof T]: ControlState };\nconst objectPath = /^([^.[]+)\\.?(.*)$/;\n\nexport class ControlGroup<T> extends ControlBase<T> {\n\tprivate controlStore = writable<Controls<T>>({} as any);\n\n\tcontrols: Readable<Controls<T>> = {\n\t\tsubscribe: this.controlStore.subscribe,\n\t};\n\n\tprivate valueDerived = derived(\n\t\tthis.controlStore,\n\t\t(controls: Controls<T>, set: (value: T) => void) => {\n\t\t\tconst keys = Object.keys(controls) as Array<keyof T>;\n\t\t\tconst controlValues = keys.map((key) => controls[key].value);\n\t\t\tconst derivedValues = derived(\n\t\t\t\tcontrolValues as any,\n\t\t\t\t(values) =>\n\t\t\t\t\t(<any[]>values).reduce(\n\t\t\t\t\t\t(acc, value, index) => (\n\t\t\t\t\t\t\t(acc[keys[index]] = value), acc\n\t\t\t\t\t\t),\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as T\n\t\t\t);\n\t\t\treturn derivedValues.subscribe(set);\n\t\t}\n\t);\n\n\tprivate touched = writable(false);\n\n\tprivate childStateDerived = derived(\n\t\tthis.controlStore,\n\t\t(controls: Controls<T>, set: (value: ControlsState<T>) => void) => {\n\t\t\tconst keys = Object.keys(controls) as Array<keyof T>;\n\t\t\tconst controlStates = keys.map((key) => controls[key].state);\n\t\t\tconst derivedStates = derived(\n\t\t\t\tcontrolStates as any,\n\t\t\t\t(states) =>\n\t\t\t\t\t(<any[]>states).reduce(\n\t\t\t\t\t\t(acc, state, index) => (\n\t\t\t\t\t\t\t(acc[keys[index]] = state), acc\n\t\t\t\t\t\t),\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as ControlsState<T>\n\t\t\t);\n\t\t\treturn derivedStates.subscribe(set);\n\t\t}\n\t);\n\n\tvalue: Writable<T> = {\n\t\tsubscribe: this.valueDerived.subscribe,\n\t\tset: (value) => this.setValue(value),\n\t\tupdate: (updater) => this.setValue(updater(get(this.valueDerived))),\n\t};\n\n\tstate = derived(\n\t\t[this.valueDerived, this.childStateDerived, this.validators, this.touched, this.meta],\n\t\t([value, childState, validators, touched, meta]) => {\n\n\t\t\tif (!this.propagateChanges && this.currentState !== null) {\n\t\t\t\treturn this.currentState\n\t\t\t}\n\t\t\tconsole.log('propagateState');\n\t\t\tconst children: Record<string, $ControlState> = {};\n\t\t\tlet childrenValid = true;\n\t\t\tlet $touched = touched;\n\t\t\tlet $dirty = false;\n\t\t\tlet $pending = false;\n\t\t\tlet $meta = meta;\n\t\t\tlet $type = 'group';\n\t\t\tfor (const key of Object.keys(childState)) {\n\t\t\t\tconst state = (children[key] = (childState as any)[\n\t\t\t\t\tkey\n\t\t\t\t] as $ControlState);\n\t\t\t\tchildrenValid = childrenValid && state.$valid;\n\t\t\t\t$touched = $touched || state.$touched;\n\t\t\t\t$dirty = $dirty || state.$dirty;\n\t\t\t\t$pending = $pending || state.$pending;\n\t\t\t}\n\t\t\tconst $error = validateIterated(validators, value);\n\n\t\t\tconst $valid = $error == null && childrenValid;\n\t\t\tlet temp =  {\n\t\t\t\t$error,\n\t\t\t\t$valid,\n\t\t\t\t$touched,\n\t\t\t\t$dirty,\n\t\t\t\t$pending,\n\t\t\t\t$meta,\n\t\t\t\t$type,\n\t\t\t\t...children,\n\t\t\t} as ControlState<T>;\n\t\t\tthis.currentState = temp\n\t\t\treturn temp\n\t\t}\n\t);\n\n\tconstructor(\n\t\tcontrols: Controls<T>, \n\t\tvalidators: ValidatorFn<T>[] = [],\n\t\tmeta?: FormControlMeta\n\t) {\n\t\tsuper(validators, meta);\n\t\tthis.controlStore.set(controls);\n\t}\n\n\tprivate iterateControls<K extends keyof T>(\n\t\tcallback: (args: [K, ControlBaseInterface<T[K]>]) => void\n\t) {\n\t\tconst controls = get(this.controlStore);\n\t\t(<[K, ControlBaseInterface<T[K]>][]>Object.entries(controls)).forEach(callback);\n\t}\n\n\tpublic setValue(value: T) {\n\t\tthis.iterateControls(([key, control]) => {\n\t\t\tconst controlValue = (value && value[key]) ?? null;\n\t\t\tcontrol.value.set(controlValue!);\n\t\t});\n\t}\n\tpublic patchValue(value: Partial<T>) {\n\t\tconst currentValue = get(this.valueDerived);\n\t\tthis.setValue({...currentValue, ...value});\n\t}\n\n\taddControl(key: string, control: ControlBase,options?:ControlEventOptions) {\n\t\tif (options && options.propagateChanges === false) {\n\t\t\tthis.propagateChanges = false;\n\t\t}\n\t\tthis.controlStore.update(\n\t\t\t(controls) => (((<any>controls)[key] = control), controls)\n\t\t);\n\t\tthis.propagateChanges = true;\n\t}\n\n\tremoveControl(key: string,options?:ControlEventOptions) {\n\t\tif (options && options.propagateChanges === false) {\n\t\t\tthis.propagateChanges = false;\n\t\t}\n\t\tthis.controlStore.update(\n\t\t\t(controls) => (delete (<any>controls)[key], controls)\n\t\t);\n\t\tthis.propagateChanges = true;\n\t}\n\n\tsetTouched(touched: boolean) {\n\t\tthis.iterateControls(([_, control]) => {\n\t\t\tcontrol.setTouched(touched);\n\t\t});\n\t\tthis.touched.set(touched);\n\t}\n\n\tchild(path: string): ControlBaseInterface<T> | null {\n\t\tconst [_, name, rest] = path.match(objectPath) || [];\n\t\tconst controls = get(this.controlStore);\n\t\tconst control =\n\t\t\t(name && ((controls as any)[name] as ControlBaseInterface<T>)) || null;\n\t\tif (!control) return null!;\n\t\treturn rest ? control.child(rest) : control;\n\t}\n\n\treset(value?: Partial<T>) {\n\t\tthis.iterateControls(([key, control]) => {\n\t\t\tconst controlValue = (value && value[key]) || undefined;\n\t\t\tcontrol.reset(controlValue!);\n\t\t});\n\t}\n}\n\nconst arrayPath = /^\\[(\\d+)\\]\\.?(.*)$/;\n\nexport class ControlArray<T> extends ControlBase<T[]> {\n\tprivate controlStore = writable(this._controls);\n\n\tprivate touched = writable(false);\n\n\tcontrols: Readable<ControlBaseInterface<T>[]> = {\n\t\tsubscribe: this.controlStore.subscribe,\n\t};\n\n\tprivate valueDerived = derived(\n\t\tthis.controlStore,\n\t\t(controls: ControlBaseInterface<T>[], set: (value: T[]) => void) => {\n\t\t\tconst derivedValues = derived(\n\t\t\t\tcontrols.map((control) => control.value) as any,\n\t\t\t\t(values) => values as T[]\n\t\t\t);\n\t\t\treturn derivedValues.subscribe(set);\n\t\t}\n\t);\n\n\tprivate childStateDerived = derived(\n\t\tthis.controlStore,\n\t\t(controls: ControlBaseInterface<T>[], set: (value: $ControlState[]) => void) => {\n\t\t\tconst derivedStates = derived(\n\t\t\t\tcontrols.map((control) => control.state) as any,\n\t\t\t\t(values) => values as $ControlState[]\n\t\t\t);\n\t\t\treturn derivedStates.subscribe(set);\n\t\t}\n\t);\n\n\tvalue: Writable<T[]> = {\n\t\tsubscribe: this.valueDerived.subscribe,\n\t\tset: (value) => this.setValue(value),\n\t\tupdate: (updater) => this.setValue(updater(get(this.valueDerived))),\n\t};\n\n\tstate = derived(\n\t\t[this.valueDerived, this.childStateDerived, this.validators, this.touched],\n\t\t([value, childState, validators, touched]) => {\n\t\t\tconst arrayState = {} as $ControlState & { list: $ControlState[] };\n\t\t\tarrayState.list = [];\n\t\t\tlet childrenValid = true;\n\t\t\tarrayState.$touched = touched;\n\t\t\tfor (let i = 0, len = childState.length; i < len; i++) {\n\t\t\t\tconst state = childState[i];\n\t\t\t\tarrayState.list[i] = state;\n\t\t\t\tchildrenValid = childrenValid && state.$valid;\n\t\t\t\tarrayState.$touched = arrayState.$touched || state.$touched || false;\n\t\t\t\tarrayState.$dirty = arrayState.$dirty || state.$dirty;\n\t\t\t}\n\t\t\tarrayState.$error = validateIterated(validators, value, );\n\t\t\tarrayState.$valid = arrayState.$error == null && childrenValid;\n\t\t\tarrayState.$meta = get(this.meta);\n\t\t\tarrayState.$type = 'array';\n\n\t\t\treturn arrayState as ControlState<T[]>;\n\t\t}\n\t);\n\n\tconstructor(\n\t\tprivate readonly _controls: ControlBaseInterface<T>[],\n\t\tvalidators: ValidatorFn<T[]>[] = [],\n\t\tmeta?: FormControlMeta\n\t) {\n\t\tsuper(validators, meta);\n\t}\n\n\tprivate iterateControls(\n\t\tcallback: (control: ControlBaseInterface<T>, index: number) => void\n\t) {\n\t\tconst controls: ControlBaseInterface<T>[] = get(this.controlStore);\n\t\tcontrols.forEach(callback);\n\t}\n\n\tprivate sortArray(val: ControlBaseInterface<T>[]) {\n\t\tconst currentControls = get(this.controlStore);\n\t\tlet newOrderIds = val.map((control) => control.id);\n\t\tlet newOrder = newOrderIds.map((id) => currentControls.find((control) => control.id === id));\n\t\tnewOrder = newOrder.filter((control) => control !== undefined) ;\n\t\tthis.controlStore.set(newOrder as ControlBaseInterface<T>[]);\n\n\t}\n\tsetValue(value: T[]) {\n\t\tthis.iterateControls((control, index) => {\n\t\t\tconst controlValue = (value && value[index]) || null;\n\t\t\tcontrol.value.set(controlValue!);\n\t\t});\n\t}\n\n\tsetTouched(touched: boolean) {\n\t\tthis.touched.set(touched);\n\t\tthis.iterateControls((control) => control.setTouched(touched));\n\t}\n\n\tpushControl(control: ControlBaseInterface<T>) {\n\t\tthis.controlStore.update(\n\t\t\t(controls) => (controls.push(control), controls)\n\t\t);\n\t}\n\n\taddControlAt(index: number, control: ControlBaseInterface<T>) {\n\t\tthis.controlStore.update(\n\t\t\t(controls) => (controls.splice(index, 0, control), controls)\n\t\t);\n\t}\n\n\tremoveControlAt(index: number) {\n\t\tthis.controlStore.update(\n\t\t\t(controls) => (controls.splice(index, 1), controls)\n\t\t);\n\t}\n\n\tremoveControl(control: ControlBaseInterface<T>) {\n\t\tthis.controlStore.update((controls) =>\n\t\t\tcontrols.filter((c) => c !== control)\n\t\t);\n\t}\n\n\tslice(start?: number, end?: number) {\n\t\tthis.controlStore.update((controls) => controls.slice(start, end));\n\t}\n\n\t//@ts-ignore\n\tchild(path: string): ControlBaseInterface<T> | null {\n\t\tconst [_, index, rest] = path.match(arrayPath) || [];\n\t\tconst controls: ControlBaseInterface<T>[] = get(this.controlStore);\n\t\tconst control = (index != null && controls[+index]) || null;\n\t\tif (!control) return null!;\n\t\treturn rest ? control.child(rest) : control;\n\t}\n\n\treset(value?: T[]) {\n\t\tthis.iterateControls((control, index) => {\n\t\t\tconst controlValue = (value && value[index]) || null;\n\t\t\tcontrol.reset(controlValue!);\n\t\t});\n\t}\n}\n","import { get, Readable } from 'svelte/store';\nimport {Control} from \"./control\";\nimport {$ControlState} from \"./interfaces\";\n\n\nexport const controlClasses = (el: HTMLElement, control: Control) => {\n\tif (!(control instanceof Control)) throw new Error('must be used with a Control class');\n\n\tconst classList = el.classList;\n\n\tconst stateSub = control.state.subscribe((state) => {\n\t\tif (state.$error) {\n\t\t\tclassList.add('invalid');\n\t\t\tclassList.remove('valid');\n\t\t} else {\n\t\t\tclassList.add('valid');\n\t\t\tclassList.remove('invalid');\n\t\t}\n\n\t\tif (state.$dirty) {\n\t\t\tclassList.add('dirty');\n\t\t\tclassList.remove('pristine');\n\t\t} else {\n\t\t\tclassList.add('pristine');\n\t\t\tclassList.remove('dirty');\n\t\t}\n\n\t\tif (state.$touched) {\n\t\t\tclassList.add('touched');\n\t\t} else {\n\t\t\tclassList.remove('touched');\n\t\t}\n\n\t});\n\n\tconst eventNames = ['blur', 'focusout'];\n\n\tconst unregister = () => eventNames.forEach(eventName => el.removeEventListener(eventName, touchedFn));\n\n\tconst touchedFn = () => {\n\t\tif ((<$ControlState>get(control.state)).$touched) return;\n\t\tcontrol.setTouched(true);\n\t}\n\n\teventNames.forEach(eventName => el.addEventListener(eventName, touchedFn));\n\n\treturn {\n\t\tdestroy() {\n\t\t\tunregister();\n\t\t\tstateSub();\n\t\t}\n\t}\n};\n","import {ControlBase} from \"./control\";\n\nexport interface ValidationError<D = any> {\n\t[name: string]: D;\n}\n\nexport type ValidatorFn<T = any, D = any> = (fieldValue: T, control: ControlBase) => ValidationError<D> | null;\n\ntype ValidatorFactory<C = unknown, T = any, D = any> = (config: C) => ValidatorFn<T, D>;\n\nconst empty = (value: any) => value == null || `${value}` === '';\n\nexport const required: ValidatorFn<string | number | boolean, boolean> = value => {\n\tlet stringValue = value != null && value !== false ? `${value}`.trim() : '';\n\treturn stringValue !== '' ? null : { required: true };\n};\n\nconst emailFormat = /^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$/;\nexport const email: ValidatorFn<string, boolean> = email => {\n\tconst valid = empty(email) || emailFormat.test(email);\n\treturn valid ? null : { email: true };\n};\n\nexport const minLength: ValidatorFactory<number, string, number> = min => value => {\n\tconst valid = empty(value) || min == null || `${value}`.trim().length >= min;\n\treturn valid ? null : { minLength: min };\n};\n\nexport const maxLength: ValidatorFactory<number, string, number> = max => value => {\n\tconst valid = empty(value) || max == null || `${value}`.trim().length <= max;\n\treturn valid ? null : { maxLength: max };\n};\n\nexport const number: ValidatorFn<string | number, boolean> = number => {\n\tconst valid = empty(number) || !isNaN(+number);\n\treturn valid ? null : { number: true };\n};\n\nconst decimalFormat = /^\\d*\\.?\\d+$/;\nexport const decimal: ValidatorFn<string | number, boolean> = number => {\n\tconst valid = empty(number) || !isNaN(+number) && decimalFormat.test(`${number}`);\n\treturn valid ? null : { decimal: true };\n};\n\nconst intFormat = /^\\d+$/;\nexport const integer: ValidatorFn<string | number, boolean> = number => {\n\tconst valid = empty(number) || !isNaN(+number) && intFormat.test(`${number}`);\n\treturn valid ? null : { integer: true };\n};\n\n\nexport const min: ValidatorFactory<number, string | number, number> = min => number => {\n\tconst valid = empty(number) || !isNaN(+number) && (min == null || number >= min);\n\treturn valid ? null : { min };\n};\n\nexport const max: ValidatorFactory<number, string | number, number> = max => number => {\n\tconst valid = empty(number) || !isNaN(+number) && (max == null || number <= max);\n\treturn valid ? null : { max };\n};\n\nexport const pattern: ValidatorFactory<RegExp, string, string> = re => text => {\n\tconst valid = empty(text) || (re == null || re.test(text));\n\treturn valid ? null : { pattern: `${re}`};\n};\n"],"names":["validateIterated","validators","fieldValue","Array","isArray","validator","result","control","e","console","error","getRandomValues","rnds8","Uint8Array","rng","crypto","bind","msCrypto","Error","validate","uuid","REGEX","test","byteToHex","i","push","toString","substr","v4","options","buf","offset","rnds","random","arr","arguments","length","undefined","toLowerCase","TypeError","stringify","defaultMeta","type","ControlBase","[object Object]","meta","this","uuidv4","writable","label","name","set","currentMeta","get","Control","initial","super","derived","value","touched","$touched","$dirty","$error","$valid","$pending","$meta","$type","Promise","then","ret","catch","err","serverError","objectPath","ControlGroup","controls","subscribe","controlStore","keys","Object","controlValues","map","key","values","reduce","acc","index","controlStates","state","states","valueDerived","setValue","update","updater","childStateDerived","childState","propagateChanges","currentState","log","children","childrenValid","temp","callback","entries","forEach","iterateControls","controlValue","currentValue","_","setTouched","path","rest","match","child","reset","arrayPath","ControlArray","_controls","arrayState","list","len","val","currentControls","newOrder","id","find","filter","splice","c","start","end","slice","controlClasses","el","classList","stateSub","add","remove","eventNames","touchedFn","eventName","addEventListener","removeEventListener","empty","required","trim","emailFormat","email","minLength","min","maxLength","max","number","isNaN","decimalFormat","decimal","intFormat","integer","pattern","re","text"],"mappings":"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"}